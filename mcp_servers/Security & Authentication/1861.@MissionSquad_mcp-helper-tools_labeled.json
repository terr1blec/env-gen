{
  "labels": {
    "analysis": "The MCP Server serves as a versatile utility toolkit for data encoding/decoding, geolocation services, and security operations. Its core functionality revolves around transforming and manipulating data formats (Base64, URL, HTML), generating unique identifiers (UUID, QR codes), and handling time zone conversions. Additionally, it offers cryptographic operations like hashing and hash comparison, as well as system diagnostics through IP-based geolocation. The server appears to be designed for streamlining automation, data processing, and security-related operations within LLM agents and applications.",
    "reasoning": "The primary label \"Security & Authentication\" was chosen because many of the tools (hashing, geolocation, QR code generation, UUID generation) are directly related to security-related operations and authentication workflows. Secondary labels \"Data Analysis & Processing\" and \"Operating System\" were selected as these tools also facilitate general data transformation and system-level utility functions (like timezone conversions). No custom label is needed as the predefined categories adequately cover the server's functionality.",
    "primary_label": "Security & Authentication",
    "secondary_labels": [
      "Data Analysis & Processing",
      "Operating System"
    ],
    "custom_label": null,
    "is_connected": true,
    "is_remote_tool_valid": true,
    "featured_server": false
  },
  "metadata": {
    "server_id": 1860,
    "server_name": "Helper Tools",
    "rank_by_usage": 1861,
    "usage_count": "Not available",
    "original_file": "../crawler/smithery/@MissionSquad_mcp-helper-tools.json",
    "mode": "smithery",
    "timestamp": 1751938055,
    "remote_server_response": {
      "url": "https://server.smithery.ai/@MissionSquad/mcp-helper-tools/mcp?api_key=8675feae-43b6-4170-beb5-d8fa5a938222&profile=monetary-anteater-CCaAaT",
      "is_success": true,
      "error": null,
      "tools": [
        {
          "name": "encodeBase64",
          "description": "Encode input data to Base64",
          "input_schema": {
            "type": "object",
            "properties": {
              "input": {
                "type": "string",
                "description": "Data to encode"
              }
            },
            "required": [
              "input"
            ]
          },
          "annotations": null
        },
        {
          "name": "decodeBase64",
          "description": "Decode Base64 input data",
          "input_schema": {
            "type": "object",
            "properties": {
              "input": {
                "type": "string",
                "description": "Data to decode"
              }
            },
            "required": [
              "input"
            ]
          },
          "annotations": null
        },
        {
          "name": "encodeUrl",
          "description": "Encode input data to URL-encoded format",
          "input_schema": {
            "type": "object",
            "properties": {
              "input": {
                "type": "string",
                "description": "Data to encode"
              }
            },
            "required": [
              "input"
            ]
          },
          "annotations": null
        },
        {
          "name": "decodeUrl",
          "description": "Decode URL-encoded input data",
          "input_schema": {
            "type": "object",
            "properties": {
              "input": {
                "type": "string",
                "description": "Data to decode"
              }
            },
            "required": [
              "input"
            ]
          },
          "annotations": null
        },
        {
          "name": "encodeHtml",
          "description": "Encode input data to HTML-encoded format",
          "input_schema": {
            "type": "object",
            "properties": {
              "input": {
                "type": "string",
                "description": "Data to encode"
              }
            },
            "required": [
              "input"
            ]
          },
          "annotations": null
        },
        {
          "name": "decodeHtml",
          "description": "Decode HTML-encoded input data",
          "input_schema": {
            "type": "object",
            "properties": {
              "input": {
                "type": "string",
                "description": "Data to decode"
              }
            },
            "required": [
              "input"
            ]
          },
          "annotations": null
        },
        {
          "name": "geolocate",
          "description": "Get geolocation information for an IP address or domain",
          "input_schema": {
            "type": "object",
            "properties": {
              "query": {
                "type": "string",
                "description": "IP address or domain to lookup"
              }
            },
            "required": [
              "query"
            ]
          },
          "annotations": null
        },
        {
          "name": "clearGeoCache",
          "description": "Clear the geolocation cache",
          "input_schema": {
            "type": "object",
            "properties": {}
          },
          "annotations": null
        },
        {
          "name": "generateUUID",
          "description": "Generate a random UUID using crypto.randomUUID()",
          "input_schema": {
            "type": "object",
            "properties": {}
          },
          "annotations": null
        },
        {
          "name": "generateQRCode",
          "description": "Generate a QR code from input data",
          "input_schema": {
            "type": "object",
            "properties": {
              "data": {
                "type": "string",
                "description": "Data to encode in QR code"
              },
              "type": {
                "type": "string",
                "description": "Output type (terminal, svg, or base64)",
                "enum": [
                  "terminal",
                  "svg",
                  "base64"
                ],
                "default": "terminal"
              },
              "errorCorrectionLevel": {
                "type": "string",
                "description": "Error correction level",
                "enum": [
                  "L",
                  "M",
                  "Q",
                  "H"
                ],
                "default": "M"
              }
            },
            "required": [
              "data"
            ]
          },
          "annotations": null
        },
        {
          "name": "convertTimezone",
          "description": "Convert date/time between timezones using Luxon",
          "input_schema": {
            "type": "object",
            "properties": {
              "date": {
                "type": "string",
                "description": "Date/time string to convert (ISO 8601 format)"
              },
              "fromTZ": {
                "type": "string",
                "description": "Source timezone (IANA timezone identifier)"
              },
              "toTZ": {
                "type": "string",
                "description": "Target timezone (IANA timezone identifier)"
              },
              "format": {
                "type": "string",
                "description": "Output format (full, date, time, iso)",
                "enum": [
                  "full",
                  "date",
                  "time",
                  "iso"
                ],
                "default": "full"
              }
            },
            "required": [
              "date",
              "fromTZ",
              "toTZ"
            ]
          },
          "annotations": null
        },
        {
          "name": "listTimezones",
          "description": "List all available IANA timezones",
          "input_schema": {
            "type": "object",
            "properties": {
              "region": {
                "type": "string",
                "description": "Filter timezones by region (e.g., America, Europe)",
                "optional": true
              }
            }
          },
          "annotations": null
        },
        {
          "name": "hashData",
          "description": "Hash input data using Node.js crypto module",
          "input_schema": {
            "type": "object",
            "properties": {
              "input": {
                "type": "string",
                "description": "Data to hash"
              },
              "algorithm": {
                "type": "string",
                "description": "Hash algorithm to use",
                "enum": [
                  "md5",
                  "sha1",
                  "sha256",
                  "sha512"
                ],
                "default": "sha256"
              },
              "encoding": {
                "type": "string",
                "description": "Output encoding",
                "enum": [
                  "hex",
                  "base64"
                ],
                "default": "hex"
              }
            },
            "required": [
              "input"
            ]
          },
          "annotations": null
        },
        {
          "name": "compareHashes",
          "description": "Compare two hashes in constant time",
          "input_schema": {
            "type": "object",
            "properties": {
              "hash1": {
                "type": "string",
                "description": "First hash to compare"
              },
              "hash2": {
                "type": "string",
                "description": "Second hash to compare"
              }
            },
            "required": [
              "hash1",
              "hash2"
            ]
          },
          "annotations": null
        }
      ],
      "tool_count": 14,
      "tool_names": [
        "encodeBase64",
        "decodeBase64",
        "encodeUrl",
        "decodeUrl",
        "encodeHtml",
        "decodeHtml",
        "geolocate",
        "clearGeoCache",
        "generateUUID",
        "generateQRCode",
        "convertTimezone",
        "listTimezones",
        "hashData",
        "compareHashes"
      ]
    },
    "server_info_crawled": {
      "id": 1860,
      "name": "Helper Tools",
      "author": "@MissionSquad/mcp-helper-tools",
      "overview": "Enhance your LLM agents with powerful utilities for encoding, geolocation, security, and more. Leverage system diagnostics and generate QR codes effortlessly to streamline your tasks. Empower your applications with a versatile toolkit for automation and data handling.",
      "repository_url": "https://github.com/MissionSquad/mcp-helper-tools",
      "homepage": "https://smithery.ai/server/@MissionSquad/mcp-helper-tools",
      "remote_or_local": "Remote",
      "license": "Apache-2.0",
      "usage_count": "Not available",
      "success_rate": "Not available",
      "tags": [
        "search",
        "web",
        "api",
        "mcp"
      ],
      "categories": [
        "search",
        "api"
      ],
      "file_path": "../crawler/smithery/@MissionSquad_mcp-helper-tools.json",
      "tools_count": 14,
      "tools": [
        {
          "name": "encodeBase64",
          "description": "Encode input data to Base64",
          "input_schema": {
            "type": "object",
            "properties": {
              "input": {
                "type": "string",
                "description": "Data to encode"
              }
            },
            "required": [
              "input"
            ]
          },
          "annotations": null
        },
        {
          "name": "decodeBase64",
          "description": "Decode Base64 input data",
          "input_schema": {
            "type": "object",
            "properties": {
              "input": {
                "type": "string",
                "description": "Data to decode"
              }
            },
            "required": [
              "input"
            ]
          },
          "annotations": null
        },
        {
          "name": "encodeUrl",
          "description": "Encode input data to URL-encoded format",
          "input_schema": {
            "type": "object",
            "properties": {
              "input": {
                "type": "string",
                "description": "Data to encode"
              }
            },
            "required": [
              "input"
            ]
          },
          "annotations": null
        },
        {
          "name": "decodeUrl",
          "description": "Decode URL-encoded input data",
          "input_schema": {
            "type": "object",
            "properties": {
              "input": {
                "type": "string",
                "description": "Data to decode"
              }
            },
            "required": [
              "input"
            ]
          },
          "annotations": null
        },
        {
          "name": "encodeHtml",
          "description": "Encode input data to HTML-encoded format",
          "input_schema": {
            "type": "object",
            "properties": {
              "input": {
                "type": "string",
                "description": "Data to encode"
              }
            },
            "required": [
              "input"
            ]
          },
          "annotations": null
        },
        {
          "name": "decodeHtml",
          "description": "Decode HTML-encoded input data",
          "input_schema": {
            "type": "object",
            "properties": {
              "input": {
                "type": "string",
                "description": "Data to decode"
              }
            },
            "required": [
              "input"
            ]
          },
          "annotations": null
        },
        {
          "name": "geolocate",
          "description": "Get geolocation information for an IP address or domain",
          "input_schema": {
            "type": "object",
            "properties": {
              "query": {
                "type": "string",
                "description": "IP address or domain to lookup"
              }
            },
            "required": [
              "query"
            ]
          },
          "annotations": null
        },
        {
          "name": "clearGeoCache",
          "description": "Clear the geolocation cache",
          "input_schema": {
            "type": "object",
            "properties": {}
          },
          "annotations": null
        },
        {
          "name": "generateUUID",
          "description": "Generate a random UUID using crypto.randomUUID()",
          "input_schema": {
            "type": "object",
            "properties": {}
          },
          "annotations": null
        },
        {
          "name": "generateQRCode",
          "description": "Generate a QR code from input data",
          "input_schema": {
            "type": "object",
            "properties": {
              "data": {
                "type": "string",
                "description": "Data to encode in QR code"
              },
              "type": {
                "type": "string",
                "description": "Output type (terminal, svg, or base64)",
                "enum": [
                  "terminal",
                  "svg",
                  "base64"
                ],
                "default": "terminal"
              },
              "errorCorrectionLevel": {
                "type": "string",
                "description": "Error correction level",
                "enum": [
                  "L",
                  "M",
                  "Q",
                  "H"
                ],
                "default": "M"
              }
            },
            "required": [
              "data"
            ]
          },
          "annotations": null
        },
        {
          "name": "convertTimezone",
          "description": "Convert date/time between timezones using Luxon",
          "input_schema": {
            "type": "object",
            "properties": {
              "date": {
                "type": "string",
                "description": "Date/time string to convert (ISO 8601 format)"
              },
              "fromTZ": {
                "type": "string",
                "description": "Source timezone (IANA timezone identifier)"
              },
              "toTZ": {
                "type": "string",
                "description": "Target timezone (IANA timezone identifier)"
              },
              "format": {
                "type": "string",
                "description": "Output format (full, date, time, iso)",
                "enum": [
                  "full",
                  "date",
                  "time",
                  "iso"
                ],
                "default": "full"
              }
            },
            "required": [
              "date",
              "fromTZ",
              "toTZ"
            ]
          },
          "annotations": null
        },
        {
          "name": "listTimezones",
          "description": "List all available IANA timezones",
          "input_schema": {
            "type": "object",
            "properties": {
              "region": {
                "type": "string",
                "description": "Filter timezones by region (e.g., America, Europe)",
                "optional": true
              }
            }
          },
          "annotations": null
        },
        {
          "name": "hashData",
          "description": "Hash input data using Node.js crypto module",
          "input_schema": {
            "type": "object",
            "properties": {
              "input": {
                "type": "string",
                "description": "Data to hash"
              },
              "algorithm": {
                "type": "string",
                "description": "Hash algorithm to use",
                "enum": [
                  "md5",
                  "sha1",
                  "sha256",
                  "sha512"
                ],
                "default": "sha256"
              },
              "encoding": {
                "type": "string",
                "description": "Output encoding",
                "enum": [
                  "hex",
                  "base64"
                ],
                "default": "hex"
              }
            },
            "required": [
              "input"
            ]
          },
          "annotations": null
        },
        {
          "name": "compareHashes",
          "description": "Compare two hashes in constant time",
          "input_schema": {
            "type": "object",
            "properties": {
              "hash1": {
                "type": "string",
                "description": "First hash to compare"
              },
              "hash2": {
                "type": "string",
                "description": "Second hash to compare"
              }
            },
            "required": [
              "hash1",
              "hash2"
            ]
          },
          "annotations": null
        }
      ],
      "python_sdk": "import mcp\nfrom mcp.client.streamable_http import streamablehttp_client\nimport json\nimport base64\n\nsmithery_api_key = \"\"\nurl = f\"https://server.smithery.ai/@MissionSquad/mcp-helper-tools/mcp?api_key={smithery_api_key}\"\n\nasync def main():\n    # Connect to the server using HTTP client\n    async with streamablehttp_client(url) as (read_stream, write_stream, _):\n        async with mcp.ClientSession(read_stream, write_stream) as session:\n            # Initialize the connection\n            await session.initialize()\n            # List available tools\n            tools_result = await session.list_tools()\n            print(f\"Available tools: {', '.join([t.name for t in tools_result.tools])}\")\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())",
      "configuration_schema": "",
      "smithery_configuration_requirements": [],
      "python_sdk_config": "",
      "python_sdk_url": "https://server.smithery.ai/@MissionSquad/mcp-helper-tools/mcp?api_key={smithery_api_key}"
    },
    "source_filename": "1861.@MissionSquad_mcp-helper-tools_prepared.json",
    "processed_timestamp": 1753731940,
    "processing_mode": "smithery",
    "rank": 1650
  }
}