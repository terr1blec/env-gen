{
  "labels": {
    "analysis": "The Chroma MCP Server is primarily focused on managing vector databases for advanced semantic search and retrieval, particularly for integrating with LLM applications. Its tools enable the creation, modification, and querying of collections with vector embeddings, including advanced filtering and metadata operations. Additionally, it provides specialized tools for dynamic, reflective problem-solving through thought chains, which are persisted and managed within the Chroma database.",
    "reasoning": "The primary label \"AI/ML Tools\" is chosen because the server's core functionality revolves around vector database operations, which are fundamental to machine learning and AI applications, particularly in semantic search and retrieval. The secondary labels \"Database Operations\" and \"Development Tools\" were selected because the server's tools are focused on database management operations (creating, modifying, querying collections) and are designed for integration into AI/ML applications, which aligns with development workflows. The custom label \"Vector Database Management\" captures the specific type of database operations handled by this server, which is unique to vector databases.",
    "primary_label": "AI/ML Tools",
    "secondary_labels": [
      "Database Operations",
      "Development Tools"
    ],
    "custom_label": "Vector Database Management",
    "is_connected": false,
    "is_remote_tool_valid": false,
    "featured_server": false
  },
  "metadata": {
    "server_id": 1729,
    "server_name": "Chroma MCP Server",
    "rank_by_usage": 1730,
    "usage_count": "Not available",
    "original_file": "../crawler/smithery/@chroma-core_chroma-mcp.json",
    "mode": "smithery",
    "timestamp": 1751941824,
    "remote_server_response": {
      "url": "https://server.smithery.ai/@chroma-core/chroma-mcp/mcp?api_key=8675feae-43b6-4170-beb5-d8fa5a938222&profile=monetary-anteater-CCaAaT",
      "is_success": false,
      "error": "unhandled errors in a TaskGroup (1 sub-exception)",
      "tools": [],
      "tool_count": 0,
      "tool_names": []
    },
    "server_info_crawled": {
      "id": 1729,
      "name": "Chroma MCP Server",
      "author": "@chroma-core/chroma-mcp",
      "overview": "Integrate vector database capabilities into your LLM applications. Effortlessly manage collections, perform semantic searches, and retrieve data with advanced filtering. Enhance your AI models with powerful data retrieval features for improved context and performance.",
      "repository_url": "https://github.com/chroma-core/chroma-mcp",
      "homepage": "https://smithery.ai/server/@chroma-core/chroma-mcp",
      "remote_or_local": "Remote",
      "license": "Smithery",
      "usage_count": "Not available",
      "success_rate": "Not available",
      "tags": [
        "search",
        "web",
        "api",
        "mcp"
      ],
      "categories": [
        "search",
        "api"
      ],
      "file_path": "../crawler/smithery/@chroma-core_chroma-mcp.json",
      "tools_count": 15,
      "tools": [
        {
          "name": "chroma_list_collections",
          "description": "Deploy Server Chroma MCP Server Claim Server @chroma-core/chroma-mcp Try in Playground chroma_list_collections",
          "parameters": [
            {
              "name": "List",
              "required": false,
              "type": "string"
            },
            {
              "name": "of",
              "required": false,
              "type": "string"
            },
            {
              "name": "collection",
              "required": false,
              "type": "string"
            },
            {
              "name": "names",
              "required": false,
              "type": "string"
            }
          ]
        },
        {
          "name": "chroma_create_collection",
          "description": "Create a new Chroma collection with configurable HNSW parameters. Args: collection_name: Name of the collection to create hnsw_space: Distance function used in HNSW index. Options: 'l2', 'ip', 'cosine' hnsw_construction_ef: Size of the dynamic candidate list for constructing the HNSW graph hnsw_search_ef: Size of the dynamic candidate list for searching the HNSW graph hnsw_M: Number of bi-directional links created for every new element hnsw_num_threads: Number of threads to use during HNSW construction hnsw_resize_factor: Factor to resize the index by when it's full hnsw_batch_size: Number of elements to batch together during index construction hnsw_sync_threshold: Number of elements to process before syncing index to disk",
          "parameters": []
        },
        {
          "name": "chroma_peek_collection",
          "description": "Peek at documents in a Chroma collection. Args: collection_name: Name of the collection to peek into limit: Number of documents to peek at",
          "parameters": []
        },
        {
          "name": "chroma_get_collection_info",
          "description": "Get information about a Chroma collection. Args: collection_name: Name of the collection to get info about",
          "parameters": []
        },
        {
          "name": "chroma_get_collection_count",
          "description": "Get the number of documents in a Chroma collection. Args: collection_name: Name of the collection to count",
          "parameters": []
        },
        {
          "name": "chroma_modify_collection",
          "description": "Modify a Chroma collection's name or metadata. Args: collection_name: Name of the collection to modify new_name: Optional new name for the collection new_metadata: Optional new metadata for the collection",
          "parameters": []
        },
        {
          "name": "chroma_delete_collection",
          "description": "Delete a Chroma collection. Args: collection_name: Name of the collection to delete",
          "parameters": []
        },
        {
          "name": "chroma_add_documents",
          "description": "Add documents to a Chroma collection. Args: collection_name: Name of the collection to add documents to documents: List of text documents to add metadatas: Optional list of metadata dictionaries for each document ids: Optional list of IDs for the documents",
          "parameters": []
        },
        {
          "name": "chroma_query_documents",
          "description": "Query documents from a Chroma collection with advanced filtering. Args: collection_name: Name of the collection to query query_texts: List of query texts to search for n_results: Number of results to return per query where: Optional metadata filters using Chroma's query operators Examples: - Simple equality: {\"metadata_field\": \"value\"} - Comparison: {\"metadata_field\": {\"$gt\": 5}} - Logical AND: {\"$and\": [{\"field1\": {\"$eq\": \"value1\"}}, {\"field2\": {\"$gt\": 5}}]} - Logical OR: {\"$or\": [{\"field1\": {\"$eq\": \"value1\"}}, {\"field1\": {\"$eq\": \"value2\"}}]} where_document: Optional document content filters include: Optional list of what to include in response. Can contain any of: [\"documents\", \"embeddings\", \"metadatas\", \"distances\"]",
          "parameters": []
        },
        {
          "name": "chroma_get_documents",
          "description": "Get documents from a Chroma collection with optional filtering. Args: collection_name: Name of the collection to get documents from ids: Optional list of document IDs to retrieve where: Optional metadata filters using Chroma's query operators Examples: - Simple equality: {\"metadata_field\": \"value\"} - Comparison: {\"metadata_field\": {\"$gt\": 5}} - Logical AND: {\"$and\": [{\"field1\": {\"$eq\": \"value1\"}}, {\"field2\": {\"$gt\": 5}}]} - Logical OR: {\"$or\": [{\"field1\": {\"$eq\": \"value1\"}}, {\"field1\": {\"$eq\": \"value2\"}}]} where_document: Optional document content filters include: Optional list of what to include in response. Can contain any of: [\"documents\", \"embeddings\", \"metadatas\"] limit: Optional maximum number of documents to return offset: Optional number of documents to skip before returning results Returns: Dictionary containing the matching documents, their IDs, and requested includes",
          "parameters": []
        },
        {
          "name": "chroma_sequential_thinking",
          "description": "A detailed tool for dynamic and reflective problem-solving through thoughts. This tool helps analyze problems through a flexible thinking process that can adapt and evolve. Each thought can build on, question, or revise previous insights as understanding deepens. Args: thought: Do not store code in the thought. It is your current thinking step, which can include: * Regular analytical steps * Revisions of previous thoughts * Questions about previous decisions * Realizations about needing more analysis * Changes in approach * Hypothesis generation * Hypothesis verification Do not make thoughts superfluous. Do not store code in the thought. thoughtNumber: Current thought number * The current number in sequence (can go beyond initial total if needed) totalThoughts: Estimated total thoughts needed * Current estimate of thoughts needed (can be adjusted up/down) sessionId: Identifier for the thinking session. Provide if this is not the first thought in the session. * A unique identifier for the current thinking session nextThoughtNeeded: Whether another thought step is needed * True if you need more thinking, even if at what seemed like the end isRevision: Whether this revises previous thinking * A boolean indicating if this thought revises previous thinking revisesThought: Which thought is being reconsidered * If isRevision is true, which thought number is being reconsidered branchFromThought: Branching point thought number * If branching, which thought number is the branching point branchId: Branch identifier * Identifier for the current branch (if any) needsMoreThoughts: If more thoughts are needed * If reaching end but realizing more thoughts needed sessionSummary: A summary of the current session. Provide when nextThoughtNeeded is false. keyThoughts: A list of key thought numbers from the current session. Provide when nextThoughtNeeded is false. persist: Whether to persist thoughts in the Chroma database You should: 1. Start with an initial estimate of needed thoughts, but be ready to adjust 2. Feel free to question or revise previous thoughts 3. Don't hesitate to add more thoughts if needed, even at the \"end\" 4. Express uncertainty when present 5. Mark thoughts that revise previous thinking or branch into new paths 6. Ignore information that is irrelevant to the current step 7. Generate a solution hypothesis when appropriate 8. Verify the hypothesis based on the Chain of Thought steps 9. Repeat the process until satisfied with the solution 10. Provide a single, ideally correct answer as the final output 11. Only set next_thought_needed to false when truly done and a satisfactory answer is reached`, Returns: Dictionary with thought metadata",
          "parameters": []
        },
        {
          "name": "chroma_get_similar_sessions",
          "description": "Retrieve the thought history for a specific session. Args: text: The text to search for Returns: Dictionary with the thought history",
          "parameters": []
        },
        {
          "name": "chroma_get_thought_history",
          "description": "Retrieve the thought history for a specific session. Args: sessionId: The session identifier Returns: Dictionary with the thought history",
          "parameters": []
        },
        {
          "name": "chroma_get_thought_branches",
          "description": "Get all branches for a specific thinking session. Args: sessionId: The session identifier Returns: Dictionary with branch information",
          "parameters": [
            {
              "name": "Dictionary",
              "required": false,
              "type": "string"
            },
            {
              "name": "with",
              "required": false,
              "type": "string"
            },
            {
              "name": "branch",
              "required": false,
              "type": "string"
            },
            {
              "name": "information",
              "required": false,
              "type": "string"
            }
          ]
        },
        {
          "name": "chroma_continue_thought_chain",
          "description": "Get the latest state of a thought chain to continue it. Args: sessionId: The session identifier branchId: Optional branch identifier to continue a specific branch Returns: Dictionary with the latest state of the thought chain",
          "parameters": []
        }
      ],
      "python_sdk": "import mcp\nfrom mcp.client.streamable_http import streamablehttp_client\nimport json\nimport base64\n\nsmithery_api_key = \"\"\nurl = f\"https://server.smithery.ai/@chroma-core/chroma-mcp/mcp?api_key={smithery_api_key}\"\n\nasync def main():\n    # Connect to the server using HTTP client\n    async with streamablehttp_client(url) as (read_stream, write_stream, _):\n        async with mcp.ClientSession(read_stream, write_stream) as session:\n            # Initialize the connection\n            await session.initialize()\n            # List available tools\n            tools_result = await session.list_tools()\n            print(f\"Available tools: {', '.join([t.name for t in tools_result.tools])}\")\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())",
      "configuration_schema": "",
      "smithery_configuration_requirements": [],
      "python_sdk_config": "",
      "python_sdk_url": "https://server.smithery.ai/@chroma-core/chroma-mcp/mcp?api_key={smithery_api_key}"
    },
    "source_filename": "cf_1730.@chroma-core_chroma-mcp_prepared.json",
    "processed_timestamp": 1753731940,
    "processing_mode": "smithery",
    "rank": 1556
  }
}