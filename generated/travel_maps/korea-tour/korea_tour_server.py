"""
Korea Tour MCP Server

A FastMCP-compliant server providing Korean tourism information
based on the offline database generated by the Database Synthesizer.
"""

import json
import os
import math
import logging
from typing import List, Optional, Dict, Any
from fastmcp import FastMCP

# Initialize FastMCP server
mcp = FastMCP(name="Korea Tour")

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Database loading and validation
def load_database() -> Dict[str, Any]:
    """Load the Korea Tour database from JSON file with robust error handling."""
    database_path = os.path.join(
        os.path.dirname(__file__), 
        "korea_tour_database.json"
    )
    
    try:
        with open(database_path, 'r', encoding='utf-8') as f:
            database = json.load(f)
        
        # Validate required top-level keys
        required_keys = ["area_codes", "tour_info", "detail_common"]
        for key in required_keys:
            if key not in database:
                raise KeyError(f"Required key '{key}' missing from database")
        
        # Validate data structure
        if not isinstance(database["area_codes"], list):
            raise ValueError("area_codes must be a list")
        if not isinstance(database["tour_info"], list):
            raise ValueError("tour_info must be a list")
        if not isinstance(database["detail_common"], list):
            raise ValueError("detail_common must be a list")
        
        logger.info(f"Successfully loaded database: {len(database['area_codes'])} area codes, "
                   f"{len(database['tour_info'])} tour info entries, "
                   f"{len(database['detail_common'])} detail common entries")
        
        return database
    
    except FileNotFoundError:
        logger.error(f"Database file not found at {database_path}")
        # Fallback to empty database structure
        return {
            "area_codes": [],
            "tour_info": [],
            "detail_common": []
        }
    except json.JSONDecodeError as e:
        logger.error(f"Invalid JSON in database file: {e}")
        raise ValueError(f"Invalid JSON in database file: {e}")
    except (KeyError, ValueError) as e:
        logger.error(f"Database validation error: {e}")
        raise ValueError(f"Database validation error: {e}")
    except Exception as e:
        logger.error(f"Unexpected error loading database: {e}")
        raise ValueError(f"Unexpected error loading database: {e}")

# Load database at module startup
try:
    DATABASE = load_database()
except Exception as e:
    logger.error(f"Failed to load database: {e}")
    # Initialize with empty database to allow server to start
    DATABASE = {
        "area_codes": [],
        "tour_info": [],
        "detail_common": []
    }

@mcp.tool()
def get_area_code(areaCode: Optional[str] = None) -> List[Dict[str, Any]]:
    """Get area codes for Korean regions.
    
    Args:
        areaCode (Optional[str]): Parent area code to get sub-areas for. 
                                 If not provided, returns top-level areas.
    
    Returns:
        List[Dict[str, Any]]: List of area code objects with areaCode, name, rnum, and sub_areas.
    """
    area_codes = DATABASE.get("area_codes", [])
    
    if areaCode is None:
        # Return top-level areas
        return area_codes
    
    # Search for the specified area code and return its sub-areas
    def find_sub_areas(areas, target_code):
        for area in areas:
            if area["areaCode"] == target_code:
                return area.get("sub_areas", [])
            # Recursively search sub-areas
            sub_result = find_sub_areas(area.get("sub_areas", []), target_code)
            if sub_result:
                return sub_result
        return []
    
    return find_sub_areas(area_codes, areaCode)

@mcp.tool()
def search_tour_info(
    areaCode: Optional[str] = None,
    contentTypeId: Optional[str] = None,
    keyword: Optional[str] = None,
    mapX: Optional[str] = None,
    mapY: Optional[str] = None,
    radius: Optional[int] = 5000
) -> List[Dict[str, Any]]:
    """Search tourism information with various filters.
    
    Args:
        areaCode (Optional[str]): Filter by area code.
        contentTypeId (Optional[str]): Filter by content type ID.
        keyword (Optional[str]): Search keyword for title matching.
        mapX (Optional[str]): X coordinate for location-based search.
        mapY (Optional[str]): Y coordinate for location-based search.
        radius (Optional[int]): Search radius in meters (default: 5000).
    
    Returns:
        List[Dict[str, Any]]: List of tour info objects matching the search criteria.
    """
    tour_info = DATABASE.get("tour_info", [])
    
    # Apply filters
    filtered_results = tour_info
    
    # Area code filter
    if areaCode:
        filtered_results = [item for item in filtered_results 
                          if item.get("areacode") == areaCode]
    
    # Content type filter
    if contentTypeId:
        filtered_results = [item for item in filtered_results 
                          if item.get("contenttypeid") == contentTypeId]
    
    # Keyword filter (case-insensitive search in title)
    if keyword:
        keyword_lower = keyword.lower()
        filtered_results = [item for item in filtered_results 
                          if keyword_lower in item.get("title", "").lower()]
    
    # Location-based filter
    if mapX and mapY:
        try:
            center_x = float(mapX)
            center_y = float(mapY)
            radius_m = float(radius)
            
            def calculate_distance(item_x, item_y, center_x, center_y):
                """Calculate approximate distance using Haversine formula."""
                try:
                    item_x_float = float(item_x)
                    item_y_float = float(item_y)
                    
                    # Convert to radians
                    lat1 = math.radians(center_y)
                    lon1 = math.radians(center_x)
                    lat2 = math.radians(item_y_float)
                    lon2 = math.radians(item_x_float)
                    
                    # Haversine formula
                    dlon = lon2 - lon1
                    dlat = lat2 - lat1
                    a = math.sin(dlat/2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon/2)**2
                    c = 2 * math.asin(math.sqrt(a))
                    
                    # Earth radius in meters
                    r = 6371000
                    return c * r
                except (ValueError, TypeError):
                    return float('inf')
            
            filtered_results = [
                item for item in filtered_results
                if calculate_distance(
                    item.get("mapx"), 
                    item.get("mapy"), 
                    center_x, 
                    center_y
                ) <= radius_m
            ]
        except (ValueError, TypeError):
            # If coordinate conversion fails, skip location filtering
            logger.warning("Invalid coordinates provided, skipping location-based filtering")
            pass
    
    return filtered_results

@mcp.tool()
def get_detail_common(contentId: str) -> Optional[Dict[str, Any]]:
    """Get detailed information for a specific content item.
    
    Args:
        contentId (str): The content ID to get detailed information for.
    
    Returns:
        Optional[Dict[str, Any]]: Detailed information object if found, None otherwise.
    """
    detail_common = DATABASE.get("detail_common", [])
    
    # Find the detail entry with matching contentId
    for detail in detail_common:
        if detail.get("contentid") == contentId:
            return detail
    
    return None

if __name__ == "__main__":
    mcp.run()