"""
National Parks Server - FastMCP-compliant MCP server for national parks information.

This server provides tools to search and access information about US national parks,
including park details, alerts, visitor centers, campgrounds, and events.
All data is sourced from the offline database generated by the Database Synthesizer.
"""

import json
import os
from typing import List, Optional, Dict, Any
from datetime import datetime
from fastmcp import FastMCP

# Initialize FastMCP server
mcp = FastMCP(name="National Parks Server")

# Database loading and validation
def get_database_path() -> str:
    """Get the database JSON file path relative to this module."""
    return os.path.join(os.path.dirname(__file__), "national_parks_server_database.json")

# Default fallback data structure
default_database = {
    "parks": [],
    "park_details": [],
    "alerts": [],
    "visitor_centers": [],
    "campgrounds": [],
    "events": []
}

# Load database from JSON file
def load_database() -> Dict[str, Any]:
    """Load the database from JSON file or return default structure."""
    database_path = get_database_path()
    try:
        if os.path.exists(database_path):
            with open(database_path, 'r', encoding='utf-8') as f:
                database = json.load(f)
            
            # Validate required top-level keys
            required_keys = ["parks", "park_details", "alerts", "visitor_centers", "campgrounds", "events"]
            for key in required_keys:
                if key not in database:
                    print(f"Warning: Missing required key '{key}' in database, using default")
                    return default_database
            
            return database
        else:
            print(f"Warning: Database file not found at {database_path}, using default data")
            return default_database
    except Exception as e:
        print(f"Error loading database: {e}, using default data")
        return default_database

# Global database instance
database = load_database()

@mcp.tool()
def findParks(
    search_term: Optional[str] = None,
    state: Optional[str] = None,
    designation: Optional[str] = None
) -> Dict[str, List[Dict[str, Any]]]:
    """Search for national parks by name, description, state, or designation.

    Args:
        search_term: Optional search term to match against park names or descriptions.
        state: Optional state code (e.g., "CA", "WY") to filter parks by location.
        designation: Optional designation type (e.g., "National Park") to filter parks.

    Returns:
        Dictionary with "parks" key containing list of matching parks with their basic information.
    """
    parks = database.get("parks", [])
    
    filtered_parks = []
    
    for park in parks:
        # Apply search term filter
        if search_term:
            search_lower = search_term.lower()
            name_match = search_lower in park.get("name", "").lower()
            desc_match = search_lower in park.get("description", "").lower()
            if not (name_match or desc_match):
                continue
        
        # Apply state filter
        if state:
            park_states = park.get("states", "").split(",")
            if state.upper() not in [s.strip().upper() for s in park_states]:
                continue
        
        # Apply designation filter
        if designation:
            park_designation = park.get("designation", "").lower()
            if designation.lower() not in park_designation:
                continue
        
        filtered_parks.append(park)
    
    return {"parks": filtered_parks}

@mcp.tool()
def getParkDetails(parkCode: str) -> Dict[str, Any]:
    """Get detailed information about a specific national park by its park code.

    Args:
        parkCode: The unique park code (e.g., "yell" for Yellowstone).

    Returns:
        Detailed park information including activities, fees, and operating hours.
    """
    park_details = database.get("park_details", [])
    
    for detail in park_details:
        if detail.get("parkCode", "").lower() == parkCode.lower():
            return detail
    
    return {"error": f"Park with code '{parkCode}' not found"}

@mcp.tool()
def getAlerts(
    parkCode: Optional[str] = None,
    search_text: Optional[str] = None,
    category: Optional[str] = None,
    start_date: Optional[str] = None,
    end_date: Optional[str] = None
) -> Dict[str, List[Dict[str, Any]]]:
    """Get current alerts for national parks with optional filtering.

    Args:
        parkCode: Optional park code to filter alerts for a specific park.
        search_text: Optional text to search in alert titles and descriptions.
        category: Optional alert category to filter by (e.g., "Safety", "Weather").
        start_date: Optional start date (YYYY-MM-DD) to filter alerts by last indexed date.
        end_date: Optional end date (YYYY-MM-DD) to filter alerts by last indexed date.

    Returns:
        Dictionary with "alerts" key containing list of alerts matching the filter criteria.
    """
    alerts = database.get("alerts", [])
    
    filtered_alerts = []
    
    for alert in alerts:
        # Apply park code filter
        if parkCode and alert.get("parkCode", "").lower() != parkCode.lower():
            continue
        
        # Apply search text filter
        if search_text:
            search_lower = search_text.lower()
            title_match = search_lower in alert.get("title", "").lower()
            desc_match = search_lower in alert.get("description", "").lower()
            if not (title_match or desc_match):
                continue
        
        # Apply category filter
        if category and alert.get("category", "").lower() != category.lower():
            continue
        
        # Apply date range filter
        if start_date or end_date:
            alert_date = alert.get("lastIndexedDate", "")
            if alert_date:
                try:
                    alert_dt = datetime.strptime(alert_date, "%Y-%m-%d")
                    
                    if start_date:
                        start_dt = datetime.strptime(start_date, "%Y-%m-%d")
                        if alert_dt < start_dt:
                            continue
                    
                    if end_date:
                        end_dt = datetime.strptime(end_date, "%Y-%m-%d")
                        if alert_dt > end_dt:
                            continue
                except ValueError:
                    # Skip date filtering if date format is invalid
                    pass
        
        filtered_alerts.append(alert)
    
    return {"alerts": filtered_alerts}

@mcp.tool()
def getVisitorCenters(
    parkCode: Optional[str] = None,
    search_name: Optional[str] = None
) -> Dict[str, List[Dict[str, Any]]]:
    """Get information about visitor centers with optional filtering.

    Args:
        parkCode: Optional park code to filter visitor centers for a specific park.
        search_name: Optional text to search in visitor center names.

    Returns:
        Dictionary with "visitor_centers" key containing list of visitor centers matching the filter criteria.
    """
    visitor_centers = database.get("visitor_centers", [])
    
    filtered_centers = []
    
    for center in visitor_centers:
        # Apply park code filter
        if parkCode and center.get("parkCode", "").lower() != parkCode.lower():
            continue
        
        # Apply name search filter
        if search_name:
            name = center.get("name", "").lower()
            if search_name.lower() not in name:
                continue
        
        filtered_centers.append(center)
    
    return {"visitor_centers": filtered_centers}

@mcp.tool()
def getCampgrounds(
    parkCode: Optional[str] = None,
    search_name: Optional[str] = None,
    amenities: Optional[List[str]] = None
) -> Dict[str, List[Dict[str, Any]]]:
    """Get information about available campgrounds with optional filtering.

    Args:
        parkCode: Optional park code to filter campgrounds for a specific park.
        search_name: Optional text to search in campground names.
        amenities: Optional list of amenities to filter by (e.g., ["Restrooms", "Fire Rings"]).

    Returns:
        Dictionary with "campgrounds" key containing list of campgrounds matching the filter criteria.
    """
    campgrounds = database.get("campgrounds", [])
    
    filtered_campgrounds = []
    
    for campground in campgrounds:
        # Apply park code filter
        if parkCode and campground.get("parkCode", "").lower() != parkCode.lower():
            continue
        
        # Apply name search filter
        if search_name:
            name = campground.get("name", "").lower()
            if search_name.lower() not in name:
                continue
        
        # Apply amenities filter
        if amenities:
            camp_amenities = [a.lower() for a in campground.get("amenities", [])]
            required_amenities = [a.lower() for a in amenities]
            
            # Check if all required amenities are present
            if not all(amenity in camp_amenities for amenity in required_amenities):
                continue
        
        filtered_campgrounds.append(campground)
    
    return {"campgrounds": filtered_campgrounds}

@mcp.tool()
def getEvents(
    parkCode: Optional[str] = None,
    category: Optional[str] = None,
    start_date: Optional[str] = None,
    end_date: Optional[str] = None
) -> Dict[str, List[Dict[str, Any]]]:
    """Find upcoming events at parks with optional filtering.

    Args:
        parkCode: Optional park code to filter events for a specific park.
        category: Optional event category to filter by (e.g., "Ranger Program", "Guided Hike").
        start_date: Optional start date (YYYY-MM-DD) to filter events starting after this date.
        end_date: Optional end date (YYYY-MM-DD) to filter events ending before this date.

    Returns:
        Dictionary with "events" key containing list of events matching the filter criteria.
    """
    events = database.get("events", [])
    
    filtered_events = []
    
    for event in events:
        # Apply park code filter
        if parkCode and event.get("parkCode", "").lower() != parkCode.lower():
            continue
        
        # Apply category filter
        if category and event.get("category", "").lower() != category.lower():
            continue
        
        # Apply date range filter
        if start_date or end_date:
            event_start = event.get("dateStart", "")
            event_end = event.get("dateEnd", "")
            
            if event_start and event_end:
                try:
                    start_dt = datetime.strptime(event_start, "%Y-%m-%d")
                    end_dt = datetime.strptime(event_end, "%Y-%m-%d")
                    
                    if start_date:
                        filter_start = datetime.strptime(start_date, "%Y-%m-%d")
                        if end_dt < filter_start:
                            continue
                    
                    if end_date:
                        filter_end = datetime.strptime(end_date, "%Y-%m-%d")
                        if start_dt > filter_end:
                            continue
                except ValueError:
                    # Skip date filtering if date format is invalid
                    pass
        
        filtered_events.append(event)
    
    return {"events": filtered_events}

if __name__ == "__main__":
    mcp.run()