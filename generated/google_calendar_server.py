"""
Google Calendar MCP Server

This module implements a FastMCP server for Google Calendar operations using
an offline dataset. It provides tools for managing calendars and events.

Required Tools:
- list-calendars: List available calendars
- list-events: List events from a calendar
- create-event: Create new calendar event
- update-event: Update existing event
- delete-event: Delete calendar event

This implementation uses the offline dataset generated by the Dataset Synthesizer
and provides realistic Google Calendar API responses.
"""

import json
import os
import uuid
from datetime import datetime, timezone
from typing import Dict, List, Any, Optional
from mcp.server.fastmcp import FastMCP

# Initialize FastMCP server
mcp = FastMCP("Google Calendar")

# Load dataset
DATASET_PATH = os.path.join(os.path.dirname(__file__), "google_calendar_dataset.json")


def load_dataset() -> Dict[str, Any]:
    """Load the calendar events dataset from JSON file."""
    try:
        with open(DATASET_PATH, 'r', encoding='utf-8') as f:
            data = json.load(f)
            # Validate dataset structure
            if isinstance(data, dict) and "calendars" in data and "events" in data:
                return data
            else:
                # Return empty dataset structure if format is unexpected
                return {
                    "metadata": {
                        "generated_at": datetime.now(timezone.utc).isoformat(),
                        "version": "1.0"
                    },
                    "calendars": [],
                    "events": {}
                }
    except (FileNotFoundError, json.JSONDecodeError) as e:
        # Return empty dataset if file doesn't exist or is invalid
        return {
            "metadata": {
                "generated_at": datetime.now(timezone.utc).isoformat(),
                "version": "1.0",
                "error": str(e)
            },
            "calendars": [],
            "events": {}
        }


def save_dataset(dataset: Dict[str, Any]) -> None:
    """Save the calendar events dataset to JSON file."""
    with open(DATASET_PATH, 'w', encoding='utf-8') as f:
        json.dump(dataset, f, indent=2, ensure_ascii=False)


def generate_event_id(summary: str, start_time: Dict[str, str]) -> str:
    """Generate a deterministic event ID matching dataset format."""
    # Use UUID5 with namespace for deterministic generation matching dataset
    namespace = uuid.UUID('{87654321-4321-8765-4321-876543210987}')
    start_str = start_time.get("dateTime") or start_time.get("date", "")
    return str(uuid.uuid5(namespace, f"event_{summary}_{start_str}"))


def validate_datetime_format(dt_str: str) -> bool:
    """Validate that a datetime string is in RFC3339 format."""
    try:
        # Try parsing the datetime string
        if 'T' in dt_str:
            # datetime format
            datetime.fromisoformat(dt_str.replace('Z', '+00:00'))
        else:
            # date format (YYYY-MM-DD)
            datetime.strptime(dt_str, '%Y-%m-%d')
        return True
    except (ValueError, TypeError):
        return False


def validate_event_data(event_data: Dict[str, Any]) -> None:
    """Validate event data structure and required fields."""
    required_fields = ["summary", "start", "end"]
    for field in required_fields:
        if field not in event_data:
            raise ValueError(f"Missing required field: {field}")
    
    # Validate datetime formats
    start = event_data["start"]
    end = event_data["end"]
    
    if "dateTime" in start:
        if not validate_datetime_format(start["dateTime"]):
            raise ValueError("Invalid start datetime format")
    elif "date" in start:
        if not validate_datetime_format(start["date"]):
            raise ValueError("Invalid start date format")
    else:
        raise ValueError("Start must have either dateTime or date field")
    
    if "dateTime" in end:
        if not validate_datetime_format(end["dateTime"]):
            raise ValueError("Invalid end datetime format")
    elif "date" in end:
        if not validate_datetime_format(end["date"]):
            raise ValueError("Invalid end date format")
    else:
        raise ValueError("End must have either dateTime or date field")


@mcp.tool()
def list_calendars() -> List[Dict[str, Any]]:
    """List available calendars.
    
    Returns:
        List of calendar objects with their metadata.
    """
    dataset = load_dataset()
    return dataset.get("calendars", [])


@mcp.tool()
def list_events(
    calendar_id: str,
    time_min: Optional[str] = None,
    time_max: Optional[str] = None
) -> List[Dict[str, Any]]:
    """List events from a calendar.
    
    Args:
        calendar_id: The calendar identifier
        time_min: Lower bound (exclusive) for an event's start time (RFC3339 timestamp)
        time_max: Upper bound (exclusive) for an event's end time (RFC3339 timestamp)
        
    Returns:
        List of event objects matching the criteria
        
    Raises:
        ValueError: If calendar_id is invalid or datetime formats are invalid
    """
    # Validate datetime formats if provided
    if time_min and not validate_datetime_format(time_min):
        raise ValueError(f"Invalid time_min format: {time_min}")
    if time_max and not validate_datetime_format(time_max):
        raise ValueError(f"Invalid time_max format: {time_max}")
    
    dataset = load_dataset()
    
    # Validate calendar ID
    valid_calendars = [cal["id"] for cal in dataset.get("calendars", [])]
    if calendar_id not in valid_calendars:
        raise ValueError(f"Invalid calendar ID: {calendar_id}. Valid calendars: {valid_calendars}")
    
    # Get events for this calendar
    events = dataset.get("events", {}).get(calendar_id, [])
    filtered_events = []
    
    for event in events:
        # Handle time filtering if provided
        if time_min or time_max:
            event_start = event.get("start", {})
            event_end = event.get("end", {})
            
            # Extract datetime string (handle both dateTime and date formats)
            start_dt_str = event_start.get("dateTime") or event_start.get("date")
            end_dt_str = event_end.get("dateTime") or event_end.get("date")
            
            if start_dt_str and end_dt_str:
                # Simple string comparison for filtering (works for ISO format)
                if time_min and start_dt_str < time_min:
                    continue
                if time_max and end_dt_str > time_max:
                    continue
        
        filtered_events.append(event)
    
    return filtered_events


@mcp.tool()
def create_event(
    calendar_id: str,
    event_data: Dict[str, Any]
) -> Dict[str, Any]:
    """Create a new calendar event.
    
    Args:
        calendar_id: The calendar identifier where the event should be created
        event_data: Event data including summary, start, end, etc.
        
    Returns:
        The created event object
        
    Raises:
        ValueError: If required fields are missing or calendar_id is invalid
    """
    # Validate calendar ID
    dataset = load_dataset()
    valid_calendars = [cal["id"] for cal in dataset.get("calendars", [])]
    if calendar_id not in valid_calendars:
        raise ValueError(f"Invalid calendar ID: {calendar_id}. Valid calendars: {valid_calendars}")
    
    # Validate event data
    validate_event_data(event_data)
    
    # Generate a unique event ID matching dataset format
    event_id = generate_event_id(event_data["summary"], event_data["start"])
    current_time = datetime.now(timezone.utc).isoformat()
    
    # Create the event with default values
    new_event = {
        "id": event_id,
        "summary": event_data["summary"],
        "description": event_data.get("description", ""),
        "location": event_data.get("location", ""),
        "start": event_data["start"],
        "end": event_data["end"],
        "attendees": event_data.get("attendees", []),
        "organizer": {
            "email": "user@example.com",  # Consistent with dataset
            "displayName": "Current User"
        },
        "created": current_time,
        "updated": current_time,
        "status": "confirmed",
        "transparency": event_data.get("transparency", "opaque"),
        "visibility": event_data.get("visibility", "default"),
        "iCalUID": f"{event_id}@google.com",
        "sequence": 0,
        "guestsCanInviteOthers": event_data.get("guestsCanInviteOthers", True),
        "guestsCanModify": event_data.get("guestsCanModify", False),
        "guestsCanSeeOtherGuests": event_data.get("guestsCanSeeOtherGuests", True),
        "reminders": event_data.get("reminders", {"useDefault": True})
    }
    
    # Add optional fields if provided
    optional_fields = ["recurrence", "colorId"]
    for field in optional_fields:
        if field in event_data:
            new_event[field] = event_data[field]
    
    # Load existing dataset and add the new event to the specified calendar
    dataset = load_dataset()
    
    # Ensure events dictionary exists for this calendar
    if "events" not in dataset:
        dataset["events"] = {}
    if calendar_id not in dataset["events"]:
        dataset["events"][calendar_id] = []
    
    # Add the new event
    dataset["events"][calendar_id].append(new_event)
    
    # Update metadata
    dataset["metadata"]["updated"] = current_time
    
    save_dataset(dataset)
    
    return new_event


@mcp.tool()
def update_event(
    calendar_id: str,
    event_id: str,
    event_data: Dict[str, Any]
) -> Dict[str, Any]:
    """Update an existing calendar event.
    
    Args:
        calendar_id: The calendar identifier
        event_id: The event identifier
        event_data: Event data including fields to update
        
    Returns:
        The updated event object
        
    Raises:
        ValueError: If calendar_id, event_id is invalid or event not found
    """
    # Validate calendar ID
    dataset = load_dataset()
    valid_calendars = [cal["id"] for cal in dataset.get("calendars", [])]
    if calendar_id not in valid_calendars:
        raise ValueError(f"Invalid calendar ID: {calendar_id}. Valid calendars: {valid_calendars}")
    
    # Get events for this calendar
    events = dataset.get("events", {}).get(calendar_id, [])
    
    # Find the event to update
    event_index = None
    for i, event in enumerate(events):
        if event["id"] == event_id:
            event_index = i
            break
    
    if event_index is None:
        raise ValueError(f"Event not found: {event_id} in calendar {calendar_id}")
    
    # Update the event
    updated_event = events[event_index].copy()
    
    # Update provided fields (validate if start/end are being updated)
    if "start" in event_data:
        if "end" not in event_data:
            raise ValueError("Cannot update start without also updating end")
        validate_event_data({"summary": updated_event["summary"], "start": event_data["start"], "end": event_data["end"]})
    elif "end" in event_data:
        raise ValueError("Cannot update end without also updating start")
    
    updateable_fields = [
        "summary", "description", "location", "start", "end",
        "attendees", "transparency", "visibility",
        "guestsCanInviteOthers", "guestsCanModify", "guestsCanSeeOtherGuests",
        "recurrence", "colorId", "reminders"
    ]
    
    for field in updateable_fields:
        if field in event_data:
            updated_event[field] = event_data[field]
    
    # Update timestamp
    current_time = datetime.now(timezone.utc).isoformat()
    updated_event["updated"] = current_time
    
    # Save the updated event
    events[event_index] = updated_event
    dataset["events"][calendar_id] = events
    dataset["metadata"]["updated"] = current_time
    save_dataset(dataset)
    
    return updated_event


@mcp.tool()
def delete_event(calendar_id: str, event_id: str) -> Dict[str, str]:
    """Delete a calendar event.
    
    Args:
        calendar_id: The calendar identifier
        event_id: The event identifier
        
    Returns:
        Confirmation message
        
    Raises:
        ValueError: If calendar_id or event_id is invalid
    """
    dataset = load_dataset()
    
    # Validate calendar ID
    valid_calendars = [cal["id"] for cal in dataset.get("calendars", [])]
    if calendar_id not in valid_calendars:
        raise ValueError(f"Invalid calendar ID: {calendar_id}. Valid calendars: {valid_calendars}")
    
    # Get events for this calendar
    events = dataset.get("events", {}).get(calendar_id, [])
    
    # Find and remove the event
    initial_count = len(events)
    events = [event for event in events if event["id"] != event_id]
    
    if len(events) == initial_count:
        raise ValueError(f"Event not found: {event_id} in calendar {calendar_id}")
    
    # Update dataset
    dataset["events"][calendar_id] = events
    dataset["metadata"]["updated"] = datetime.now(timezone.utc).isoformat()
    save_dataset(dataset)
    
    return {
        "status": "success",
        "message": f"Event {event_id} deleted successfully from calendar {calendar_id}"
    }


if __name__ == "__main__":
    # Run the server
    mcp.run(transport="stdio")